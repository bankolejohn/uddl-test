/*
 * generated by Xtext 2.33.0
 */
/*
 * Copyright (c) 2022 - 2024 Epistimis LLC (http://www.epistimis.com).
 */
package com.epistimis.uddl.ui.contentassist;

import java.lang.invoke.MethodHandles;
import java.text.MessageFormat;

import org.apache.log4j.Logger;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.jface.text.contentassist.ICompletionProposal;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.conversion.impl.QualifiedNameValueConverter;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScopeProvider;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor;

import com.epistimis.uddl.CLRealizationProcessor;
import com.epistimis.uddl.ConceptualEntityProcessor;
import com.epistimis.uddl.LPRealizationProcessor;
import com.epistimis.uddl.LogicalEntityProcessor;
import com.epistimis.uddl.PlatformEntityProcessor;
import com.epistimis.uddl.UddlQNP;
import com.epistimis.uddl.util.IndexUtilities;
import com.epistimis.uddl.uddl.LogicalAssociation;
import com.epistimis.uddl.uddl.LogicalComposition;
import com.epistimis.uddl.uddl.LogicalEntity;
import com.epistimis.uddl.uddl.LogicalMeasurement;
import com.epistimis.uddl.uddl.LogicalMeasurementAttribute;
import com.epistimis.uddl.uddl.LogicalMeasurementAxis;
import com.epistimis.uddl.uddl.LogicalParticipant;
import com.epistimis.uddl.uddl.PlatformAssociation;
import com.epistimis.uddl.uddl.PlatformComposableElement;
import com.epistimis.uddl.uddl.PlatformComposition;
import com.epistimis.uddl.uddl.PlatformEntity;
import com.epistimis.uddl.uddl.PlatformParticipant;
import com.epistimis.uddl.uddl.PlatformStruct;
import com.epistimis.uddl.uddl.UddlElement;
import com.epistimis.uddl.uddl.UddlPackage;
import com.google.inject.Inject;

/**
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#content-assist
 * on how to customize the content assistant.
 */
public class UddlProposalProvider extends AbstractUddlProposalProvider {

	private static Logger logger = Logger.getLogger(MethodHandles.lookup().lookupClass());


	final static String ABS_MEAS_REALIZATION_ERR 	= "AbstractMeasurement {0} is not realized by any PlatformDataType";
	final static String ABS_MEAS_REALIZATION_MANY 	= "AbstractMeasurement {0} is realized by multiple PlatformDataTypes - picking one";
	final static String DEFAULT_PRECISION 			= "0.01";
	final static String INDENT 						= "\t";
	final static String MEMBER_DISPLAY_FMT 			= "{0}" ;
	final static String REALIZE_ALL 				= "<<Default Realize All>>";
	final static String STRUCT_REALIZATION_ERR 		= "PlatformStruct {0} must realize a LogicalMeasurement with 2+ axes / attributes. {1} has {2}";
	final static String STRUCT_AXIS_FMT 			= "{0} {1} ( {2} ) ;" ;
	final static String STRUCT_ATTRIBUTE_FMT 		= "{0} {1} ( {2} ) -> {3} ;" ;
	final static String GENERIC_REF_DISPLAY_FMT 	= "{0} - {1}";
	
	@Inject protected UddlQNP 						qnp;
	@Inject	protected IScopeProvider 				sp; // inherited scopeProvider is private

	@Inject protected IndexUtilities 				ndxUtil;
	
	@Inject protected ConceptualEntityProcessor 	ceProc;
	@Inject protected LogicalEntityProcessor 		leProc;
	@Inject protected PlatformEntityProcessor 		peProc;
	
	@Inject protected CLRealizationProcessor		clrproc;
	@Inject protected LPRealizationProcessor		lprproc;
	
	@Inject protected CLRealizationProposalProcessor clrpproc;
	@Inject protected LPRealizationProposalProcessor lprpproc;
	
	@Inject	protected PropUtils    					pu;
	 
	protected <T extends EObject,U extends EObject> QualifiedName relativeQualifiedName(T obj, U ctx) {
		return qnp.relativeQualifiedName(obj, ctx);
	}

	public QualifiedNameValueConverter getQualifiedNameValueConverter() { return qnp.getQualifiedNameValueConverter(); }

//	UddlProposalProvider() {
//		// This should set the proposal creator when this is instantiated.
//		setCrossReferenceProposalCreator(new MinimalLengthReferenceProposalCreator());
//	}

	/**
	 * A generalized proposal acceptance process that also shortens CrossRefs if possible.
	 * @param model The model object where the reference should be filled
	 * @param ref	The reference to be filled
	 * @param context
	 * @param acceptor
	 */
	public void genAndAcceptCandidateProposal(IEObjectDescription candidate, Resource res, EReference ref, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		EObject obj = IndexUtilities.objectFromDescription(res,candidate);
		if (!(obj instanceof UddlElement)) {
			logger.error("genAndAcceptCandidateProposal called for candidate " + candidate.getQualifiedName().toString() + " that is not a UddlElement");
			return;
		}
		genAndAcceptCandidateProposal((UddlElement)obj,res,ref,context,acceptor);
	}
	public void genAndAcceptCandidateProposal(UddlElement candidate, Resource res, EReference ref, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		String desc = candidate.getDescription();
		genAndAcceptCandidateProposal(candidate,desc,res,ref,context,acceptor);
	}

	public void genAndAcceptCandidateProposal(EObject candidate, String description, Resource res, EReference ref, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		QualifiedName cname = qnp.getFullyQualifiedName(candidate);
		genAndAcceptCandidateProposal(cname, description,res,ref,context,acceptor);
	}

	public void genAndAcceptCandidateProposal(IEObjectDescription candidate, String description, Resource res, EReference ref, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		QualifiedName cname = candidate.getQualifiedName();
		genAndAcceptCandidateProposal(cname, description,res,ref,context,acceptor);
	}
	public void genAndAcceptCandidateProposal(QualifiedName name, String description, Resource res, EReference ref, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		String displayString = MessageFormat.format(GENERIC_REF_DISPLAY_FMT, name.getLastSegment(), name.toString());
		ICompletionProposal prop = createCompletionProposal(name.toString(), displayString, null, context);
		prop = pu.modifyConfigurableCompletionProposal(prop, context, ref,description);
		acceptor.accept(prop);		
	}

	/**
	 * A generalized proposal acceptance process that also shortens CrossRefs if possible.
	 * @param model The model object where the reference should be filled
	 * @param ref	The reference to be filled
	 * @param context
	 * @param acceptor
	 */
	public void acceptCommonCandidateProposals(EObject model, EReference ref, ContentAssistContext context,
			/*UddlProposalProvider pp, */ ICompletionProposalAcceptor acceptor) {

		// Get the candidates
		Iterable<IEObjectDescription> candidates = pu.getCandidateDescriptions(model, ref);
		for (IEObjectDescription candidate : candidates) {
			genAndAcceptCandidateProposal(candidate, model.eResource(),ref, context, acceptor);
		}
	}

//	/**
//	 * I think if I override this method (from AbstractJavaBasedContentProposalProvider), I can supply a proposal creator
//	 * that will automatically shortern the proposal references
//	 */
//	@Override
//	protected Function<IEObjectDescription, ICompletionProposal> getProposalFactory(String ruleName,
//			ContentAssistContext contentAssistContext) {
//		return new DefaultProposalCreator(contentAssistContext, ruleName, getQualifiedNameConverter());
//	}

	/** Logical -> Conceptual */
	

	/**
	 * The only way to force calling a super class method is by calling from the derived class. So we create this callback to 
	 * be used by clrpproc to force the call to the super class method
	 * @param obj
	 * @param ruleCall
	 * @param context
	 * @param acceptor
	 */
	public void superComplete_LogicalComposition(EObject obj, RuleCall ruleCall, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		super.complete_LogicalComposition(obj, ruleCall, context, acceptor);		
	}
	@Override
	public void complete_LogicalComposition(EObject obj, RuleCall ruleCall, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		LogicalEntity ent = null;
		if (obj instanceof LogicalEntity) { ent = (LogicalEntity)obj; }
		else if (obj instanceof LogicalComposition) { ent = (LogicalEntity)obj.eContainer(); }
		else {
			throw new RuntimeException("Can't cast to LogicalEntity:" + obj.eClass().toString());
		}
		clrpproc.complete_Composition(this,clrproc, ent, ruleCall, context, acceptor);		
	}

	@Override
	public void complete_LogicalParticipant(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		LogicalAssociation assoc = null;
		if (model instanceof LogicalAssociation) { assoc = (LogicalAssociation)model; }
		else if (model instanceof LogicalParticipant) { assoc = (LogicalAssociation)model.eContainer(); }
		else {
			throw new RuntimeException("Can't cast to LogicalAssociation:" + model.eClass().toString());
		}
		clrpproc.complete_Participant(this,clrproc, assoc, ruleCall, context, acceptor);		
		
	}
//	@Override
//	public void completeLogicalEntity_Composition(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		completeRuleCall(((RuleCall)assignment.getTerminal()), context, acceptor);
//	}
//	@Override
//	public void completeLogicalAssociation_Composition(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		completeRuleCall(((RuleCall)assignment.getTerminal()), context, acceptor);
//	}

	@Override
	public void completeLogicalComposition_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		lookupCrossReference(((CrossReference)assignment.getTerminal()), context, acceptor);
		clrpproc.completeComposition_Type(this, (LogicalEntity)model,  assignment, context, acceptor);
		
	}
	/**
	 * The only way to force calling a super class method is by calling from the derived class. So we create this callback to 
	 * be used by clrpproc to force the call to the super class method
	 * @param obj
	 * @param ruleCall
	 * @param context
	 * @param acceptor
	 */
	public void superCompleteLogicalComposition_Rolename(EObject obj, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		super.completeLogicalComposition_Rolename(obj, assignment, context, acceptor);		
	}
	@Override
	public void completeLogicalComposition_Rolename(EObject obj, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		clrpproc.completeComposition_Rolename(this, clrproc, (LogicalEntity)obj.eContainer(), assignment, context, acceptor);
	}

	@Override
	public void completeLogicalComposition_Realizes(EObject obj, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		clrpproc.completeComposition_Realizes(this, clrproc, (LogicalEntity)obj.eContainer(), assignment, context, acceptor);
	}

	@Override
	public void completeLogicalParticipant_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		lookupCrossReference(((CrossReference)assignment.getTerminal()), context, acceptor);
		clrpproc.completeParticipant_Type(this, (LogicalAssociation)model,  assignment, context, acceptor);
		
	}

	@Override
	public void completeLogicalMeasurement_Realizes(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		// Do I need to call super? Don't think so
//		super.completeLogicalMeasurement_Realizes(model,assignment,context,acceptor);
		EReference ref = UddlPackage.Literals.LOGICAL_MEASUREMENT__REALIZES;
		acceptCommonCandidateProposals(model,ref,context,acceptor);
	}


	/** Platform -> Logical */

	/** Rule methods */
	/**
	 * The only way to force calling a super class method is by calling from the derived class. So we create this callback to 
	 * be used by clrpproc to force the call to the super class method
	 * @param obj
	 * @param ruleCall
	 * @param context
	 * @param acceptor
	 */
	public void superComplete_PlatformComposition(EObject obj, RuleCall ruleCall, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		super.complete_PlatformComposition(obj, ruleCall, context, acceptor);		
	}
	@Override
	public void complete_PlatformComposition(EObject obj, RuleCall ruleCall, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		PlatformEntity ent = null;
		if (obj instanceof PlatformEntity) { ent = (PlatformEntity)obj; }
		else if (obj instanceof PlatformComposition) { ent = (PlatformEntity)obj.eContainer(); }
		else {
			throw new RuntimeException("Can't cast to PlatformEntity:" + obj.eClass().toString());
		}
		lprpproc.complete_Composition(this,lprproc, ent, ruleCall, context, acceptor);

	}

	@Override
	public void complete_PlatformParticipant(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		PlatformAssociation assoc = null;
		if (model instanceof PlatformAssociation) { assoc = (PlatformAssociation)model; }
		else if (model instanceof PlatformParticipant) { assoc = (PlatformAssociation)model.eContainer(); }
		else {
			throw new RuntimeException("Can't cast to PlatformAssociation:" + model.eClass().toString());
		}
		lprpproc.complete_Participant(this,lprproc, assoc, ruleCall, context, acceptor);		
		
	}

	/** Feature Methods */
	
//	@Override
//	public void completePlatformEntity_Composition(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		completeRuleCall(((RuleCall)assignment.getTerminal()), context, acceptor);
//	}
	
//	@Override
//	public void completePlatformAssociation_Composition(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		completeRuleCall(((RuleCall)assignment.getTerminal()), context, acceptor);
//	}

	@Override
	public void completePlatformComposition_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		lookupCrossReference(((CrossReference)assignment.getTerminal()), context, acceptor);
		lprpproc.completeComposition_Type(this, (PlatformEntity)model,  assignment, context, acceptor);
		
	}
	/**
	 * The only way to force calling a super class method is by calling from the derived class. So we create this callback to 
	 * be used by clrpproc to force the call to the super class method
	 * @param obj
	 * @param ruleCall
	 * @param context
	 * @param acceptor
	 */
	public void superCompletePlatformComposition_Rolename(EObject obj, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		super.completePlatformComposition_Rolename(obj, assignment, context, acceptor);		
	}
	@Override
	public void completePlatformComposition_Rolename(EObject obj, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		lprpproc.completeComposition_Rolename(this, lprproc, (PlatformEntity)obj.eContainer(), assignment, context, acceptor);
	}
		

	@Override
	public void completePlatformComposition_Realizes(EObject obj, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		lprpproc.completeComposition_Realizes(this, lprproc, (PlatformEntity)obj.eContainer(), assignment, context, acceptor);

	}

	@Override
	public void completePlatformParticipant_Type(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		lookupCrossReference(((CrossReference)assignment.getTerminal()), context, acceptor);
		lprpproc.completeParticipant_Type(this, (PlatformAssociation)model,  assignment, context, acceptor);
		
	}
	
	@Override
	public void completePlatformStruct_Member(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		super.completePlatformStruct_Member(model, assignment, context, acceptor);		

		PlatformStruct ps = (PlatformStruct)model;
		// Look at the realized measurement and loop through all its axes and MeasurementAttributes
		// We must have a struct member for each. The rolename should be a lowercase version of the type name for the member (for axes)
		// or the rolename (for MeasurementAattributes). 
		
		// This can realize a LogicalMeasurement or a LogicalMeasurementAxis.
		// See idlTypeConsistentlyRealizesMeasurementAxis in constraints/platform.ocl
		// 
//		List<EPackage> pkgs = new ArrayList<>();
//		pkgs.add(UddlPackage.eINSTANCE);
		
		EObject obj = ps.getRealizes();
		if (obj instanceof LogicalMeasurement) {
			LogicalMeasurement meas = (LogicalMeasurement) ps.getRealizes();
			// The measurement must have at least 2 members + attributes
			int count = meas.getAttribute().size() + meas.getMeasurementAxis().size();
			if (count < 2) {
				String msg = MessageFormat.format(STRUCT_REALIZATION_ERR,ps.getName(),meas.getName(), count);
				logger.error(msg);
			}
			String ndent = PropUtils.indent(qnp.getFullyQualifiedName(model).getSegmentCount());
			StringBuilder insertionText = new StringBuilder();
			

			// For each axis, find all the PlatformDataTypes that realize the MeasurementAxis - each of those is a possibility
			// In order to propose the entire structure, we could find every possible combination. That could get messy. For now,
			// just pick a combination since users can edit this later.
			for (LogicalMeasurementAxis axis: meas.getMeasurementAxis()) {
				PlatformComposableElement realizingPCE = (PlatformComposableElement) lprproc.getRealizingType(/*pkgs,*/axis, ABS_MEAS_REALIZATION_ERR,ABS_MEAS_REALIZATION_MANY );
				if (realizingPCE != null) {
					StringBuilder insertionTextBldr = new StringBuilder();
					insertionTextBldr.append("\n" + ndent);
					// Set the type name
					QualifiedName n = qnp.relativeQualifiedName(realizingPCE, model);
					String displayString = MessageFormat.format(MEMBER_DISPLAY_FMT,n.getLastSegment());
					insertionTextBldr.append(MessageFormat.format(STRUCT_AXIS_FMT,n.toString(), n.getLastSegment().toLowerCase(), DEFAULT_PRECISION));
					String insertionString = insertionTextBldr.toString();
					ICompletionProposal prop = createCompletionProposal(insertionString,displayString, null, context);
					prop = pu.modifyConfigurableCompletionProposal(prop, context, UddlPackage.Literals.LOGICAL_MEASUREMENT_AXIS__REALIZES,realizingPCE.getDescription());
					acceptor.accept(prop);
					insertionText.append(insertionString);					
				}
			}
			for (LogicalMeasurementAttribute attr: meas.getAttribute()) {
				// Get the type of the MeasurementAttribute - this should be realized by the StructMember's type
				EObject realizedAttrType = attr.getType();
				PlatformComposableElement realizingPCE = (PlatformComposableElement) lprproc.getRealizingType(/*pkgs,*/realizedAttrType, ABS_MEAS_REALIZATION_ERR,ABS_MEAS_REALIZATION_MANY );
				if (realizingPCE != null) {					
					StringBuilder insertionTextBldr = new StringBuilder();
					insertionTextBldr.append("\n" + ndent);
					// Set the type name
					QualifiedName typeName = qnp.relativeQualifiedName(realizingPCE, model);
					QualifiedName n = qnp.relativeQualifiedName(attr, model);
					String displayString = MessageFormat.format(MEMBER_DISPLAY_FMT,n.toString());
					insertionTextBldr.append(MessageFormat.format(STRUCT_ATTRIBUTE_FMT,typeName.toString(), n.getLastSegment().toLowerCase(), DEFAULT_PRECISION, n.toString()));
					String insertionString = insertionTextBldr.toString();
					ICompletionProposal prop = createCompletionProposal(insertionString,displayString, null, context);
					prop = pu.modifyConfigurableCompletionProposal(prop, context, UddlPackage.Literals.LOGICAL_MEASUREMENT_ATTRIBUTE__TYPE,realizingPCE.getDescription());
					acceptor.accept(prop);
					insertionText.append(insertionString);			
				}
			}
			/**
			 * Always provide the Realize All choice
			 */
			acceptor.accept(createCompletionProposal(insertionText.toString(), REALIZE_ALL, null, context));
			
		} else if (obj instanceof LogicalMeasurementAxis) {
			LogicalMeasurementAxis axis = (LogicalMeasurementAxis)obj;
//		       self.oclIsTypeOf(PlatformStruct) and
//		        self.realizedMeasurementAxis().getValueTypeUnits()
//		          = self.oclAsType(PlatformStruct).member
//		                                     ->collect(type.realizes)
//		                                     ->asSet() and
//		        self.realizedMeasurementAxis().getValueTypeUnits()->size()
//		          = self.oclAsType(PlatformStruct).member
//		                                     ->collect(type.realizes)
//		                                     ->size()               
			
		}
		
	}
	
//	@Override
//	public void complete_PlatformStructMember(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		// Each member 
//		// Look at what this object realizes and create a proposal for each - This isn't part
//		
//	}
	
}
